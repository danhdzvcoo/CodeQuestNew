const { EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');
const playerManager = require('../player');
const logger = require('../utils/logger');

module.exports = {
    name: 'interactionCreate',
    
    async execute(interaction) {
        try {
            if (interaction.isChatInputCommand()) {
                await this.handleSlashCommand(interaction);
            } else if (interaction.isButton()) {
                await this.handleButtonInteraction(interaction);
            } else if (interaction.isStringSelectMenu()) {
                await this.handleSelectMenuInteraction(interaction);
            }
        } catch (error) {
            logger.error('Error handling interaction:', error);
            
            const errorEmbed = new EmbedBuilder()
                .setColor('#FF0000')
                .setTitle('‚ùå L·ªói h·ªá th·ªëng')
                .setDescription('ƒê√£ x·∫£y ra l·ªói khi x·ª≠ l√Ω t∆∞∆°ng t√°c!')
                .setTimestamp();

            if (interaction.replied || interaction.deferred) {
                await interaction.followUp({ embeds: [errorEmbed], ephemeral: true });
            } else {
                await interaction.reply({ embeds: [errorEmbed], ephemeral: true });
            }
        }
    },

    async handleSlashCommand(interaction) {
        const command = interaction.client.commands.get(interaction.commandName);
        
        if (!command) {
            logger.warn(`No command matching ${interaction.commandName} was found.`);
            return;
        }

        try {
            await command.execute(interaction);
        } catch (error) {
            logger.error(`Error executing command ${interaction.commandName}:`, error);
            
            const errorEmbed = new EmbedBuilder()
                .setColor('#FF0000')
                .setTitle('‚ùå L·ªói l·ªánh')
                .setDescription('ƒê√£ x·∫£y ra l·ªói khi th·ª±c hi·ªán l·ªánh!')
                .setTimestamp();

            if (interaction.replied || interaction.deferred) {
                await interaction.followUp({ embeds: [errorEmbed], ephemeral: true });
            } else {
                await interaction.reply({ embeds: [errorEmbed], ephemeral: true });
            }
        }
    },

    async handleButtonInteraction(interaction) {
        const userId = interaction.user.id;
        const customId = interaction.customId;
        
        // Handle cultivation buttons
        if (customId === 'start_cultivation') {
            await this.handleStartCultivation(interaction);
        } else if (customId === 'stop_cultivation') {
            await this.handleStopCultivation(interaction);
        } else if (customId.startsWith('confirm_breakthrough_')) {
            await this.handleBreakthroughConfirm(interaction);
        } else if (customId.startsWith('accept_challenge_')) {
            await this.handlePvPAccept(interaction);
        } else if (customId.startsWith('decline_challenge_')) {
            await this.handlePvPDecline(interaction);
        } else if (customId.startsWith('confirm_boss_fight_')) {
            await this.handleBossFightConfirm(interaction);
        } else if (customId === 'confirm_registration') {
            await this.handleRegistrationConfirm(interaction);
        } else if (customId.startsWith('buy_')) {
            await this.handleShopPurchase(interaction);
        } else if (customId === 'claim_daily_rewards') {
            await this.handleClaimDailyRewards(interaction);
        } else if (customId === 'claim_weekly_rewards') {
            await this.handleClaimWeeklyRewards(interaction);
        } else {
            await interaction.reply({ content: '‚ùå T∆∞∆°ng t√°c kh√¥ng ƒë∆∞·ª£c nh·∫≠n di·ªán!', ephemeral: true });
        }
    },

    async handleSelectMenuInteraction(interaction) {
        const selected = interaction.values[0];
        
        if (interaction.customId === 'select_ranking_category') {
            await this.handleRankingCategorySelect(interaction, selected);
        } else if (interaction.customId === 'help_category_select') {
            await this.handleHelpCategorySelect(interaction, selected);
        } else if (interaction.customId.startsWith('buy_')) {
            await this.handleItemPurchaseSelect(interaction, selected);
        } else {
            await interaction.reply({ content: '‚ùå Menu kh√¥ng ƒë∆∞·ª£c nh·∫≠n di·ªán!', ephemeral: true });
        }
    },

    async handleStartCultivation(interaction) {
        const userId = interaction.user.id;
        const player = playerManager.getPlayer(userId);
        
        if (player.banned) {
            return interaction.reply({ 
                content: 'üö´ T√†i kho·∫£n c·ªßa b·∫°n ƒë√£ b·ªã c·∫•m!', 
                ephemeral: true 
            });
        }

        if (player.isCultivating) {
            return interaction.reply({ 
                content: '‚ùå B·∫°n ƒëang trong qu√° tr√¨nh tu luy·ªán!', 
                ephemeral: true 
            });
        }

        // Check daily limit
        const today = new Date().toDateString();
        const lastDate = player.lastCultivationDate ? 
            new Date(player.lastCultivationDate).toDateString() : null;
        
        if (lastDate !== today) {
            player.cultivationCount = 0;
        }

        if (player.cultivationCount >= 5) {
            return interaction.reply({ 
                content: '‚è∞ B·∫°n ƒë√£ tu luy·ªán ƒë·ªß 5 l·∫ßn h√¥m nay!', 
                ephemeral: true 
            });
        }

        // Start cultivation
        const cultivationService = require('../services/cultivationService');
        const result = await cultivationService.startCultivation(userId);
        
        if (result.success) {
            const embed = new EmbedBuilder()
                .setColor('#00FF00')
                .setTitle('üßò‚Äç‚ôÇÔ∏è B·∫ÆT ƒê·∫¶U TU LUY·ªÜN')
                .setDescription('B·∫°n ƒë√£ b·∫Øt ƒë·∫ßu tu luy·ªán! S·∫Ω t·ª± ƒë·ªông k·∫øt th√∫c sau 30 ph√∫t.')
                .addFields(
                    {
                        name: '‚è∞ Th·ªùi gian',
                        value: '30 ph√∫t',
                        inline: true
                    },
                    {
                        name: '‚ö° EXP/gi√¢y',
                        value: '1 EXP',
                        inline: true
                    },
                    {
                        name: 'üéØ T·ªïng EXP',
                        value: '1,800 EXP',
                        inline: true
                    }
                )
                .setTimestamp();

            const actionRow = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('stop_cultivation')
                        .setLabel('‚èπÔ∏è D·ª´ng tu luy·ªán')
                        .setStyle(ButtonStyle.Danger)
                );

            await interaction.reply({ embeds: [embed], components: [actionRow] });
        } else {
            await interaction.reply({ 
                content: `‚ùå ${result.message}`, 
                ephemeral: true 
            });
        }
    },

    async handleStopCultivation(interaction) {
        const userId = interaction.user.id;
        const cultivationService = require('../services/cultivationService');
        
        const result = await cultivationService.stopCultivation(userId);
        
        if (result.success) {
            const embed = new EmbedBuilder()
                .setColor('#FFA500')
                .setTitle('‚èπÔ∏è D·ª™NG TU LUY·ªÜN')
                .setDescription('B·∫°n ƒë√£ d·ª´ng tu luy·ªán!')
                .addFields(
                    {
                        name: '‚ö° EXP nh·∫≠n ƒë∆∞·ª£c',
                        value: `${result.expGained.toLocaleString()} EXP`,
                        inline: true
                    },
                    {
                        name: '‚è∞ Th·ªùi gian tu luy·ªán',
                        value: result.timeSpent,
                        inline: true
                    }
                )
                .setTimestamp();

            await interaction.update({ embeds: [embed], components: [] });
        } else {
            await interaction.reply({ 
                content: `‚ùå ${result.message}`, 
                ephemeral: true 
            });
        }
    },

    async handleBreakthroughConfirm(interaction) {
        const userId = interaction.user.id;
        const breakthroughService = require('../services/breakthroughService');
        
        const result = await breakthroughService.attemptBreakthrough(userId);
        
        const embed = new EmbedBuilder()
            .setColor(result.success ? '#00FF00' : '#FF0000')
            .setTitle(result.success ? 'üéâ ƒê·ªòT PH√Å TH√ÄNH C√îNG!' : 'üíî ƒê·ªòT PH√Å TH·∫§T B·∫†I')
            .setDescription(result.message)
            .setTimestamp();

        if (result.success) {
            embed.addFields(
                {
                    name: 'üèîÔ∏è C·∫£nh gi·ªõi m·ªõi',
                    value: result.newRealm,
                    inline: true
                },
                {
                    name: 'üí™ S·ª©c m·∫°nh tƒÉng',
                    value: `+${result.powerGain.toLocaleString()}`,
                    inline: true
                }
            );
        }

        await interaction.update({ embeds: [embed], components: [] });
    },

    async handlePvPAccept(interaction) {
        const challengeId = interaction.customId.split('_')[2];
        const pvpService = require('../services/pvpService');
        
        const result = await pvpService.acceptChallenge(challengeId, interaction.user.id);
        
        if (result.success) {
            const battleResult = await pvpService.executeBattle(result.challenge);
            
            const embed = new EmbedBuilder()
                .setColor(battleResult.winnerId === interaction.user.id ? '#00FF00' : '#FF0000')
                .setTitle('‚öîÔ∏è K·∫æT QU·∫¢ TR·∫¨N ƒê·∫§U')
                .setDescription(battleResult.battleLog)
                .addFields(
                    {
                        name: 'üèÜ Ng∆∞·ªùi th·∫Øng',
                        value: battleResult.winnerName,
                        inline: true
                    },
                    {
                        name: 'üíî Ng∆∞·ªùi thua',
                        value: battleResult.loserName,
                        inline: true
                    },
                    {
                        name: 'üéÅ Ph·∫ßn th∆∞·ªüng',
                        value: battleResult.rewards,
                        inline: false
                    }
                )
                .setTimestamp();

            await interaction.update({ embeds: [embed], components: [] });
        } else {
            await interaction.reply({ 
                content: `‚ùå ${result.message}`, 
                ephemeral: true 
            });
        }
    },

    async handlePvPDecline(interaction) {
        const challengeId = interaction.customId.split('_')[2];
        const pvpService = require('../services/pvpService');
        
        pvpService.declineChallenge(challengeId);
        
        const embed = new EmbedBuilder()
            .setColor('#FFA500')
            .setTitle('‚ùå TH√ÅCH ƒê·∫§U B·ªä T·ª™ CH·ªêI')
            .setDescription('Th√°ch ƒë·∫•u ƒë√£ b·ªã t·ª´ ch·ªëi.')
            .setTimestamp();

        await interaction.update({ embeds: [embed], components: [] });
    },

    async handleBossFightConfirm(interaction) {
        const bossId = interaction.customId.split('_')[3];
        const bossService = require('../services/bossService');
        
        const result = await bossService.fightBoss(interaction.user.id, bossId);
        
        const embed = new EmbedBuilder()
            .setColor(result.victory ? '#00FF00' : '#FF0000')
            .setTitle(result.victory ? 'üéâ CHI·∫æN TH·∫ÆNG!' : 'üíÄ TH·∫§T B·∫†I')
            .setDescription(result.battleLog)
            .addFields(
                {
                    name: result.victory ? 'üéÅ Ph·∫ßn th∆∞·ªüng' : 'üí∏ T·ªïn th·∫•t',
                    value: result.rewards || result.penalties,
                    inline: false
                }
            )
            .setTimestamp();

        await interaction.update({ embeds: [embed], components: [] });
    },

    async handleRegistrationConfirm(interaction) {
        const userId = interaction.user.id;
        const username = interaction.user.username;
        
        try {
            const dkCommand = require('../commands/dk');
            const newPlayer = await dkCommand.handleRegistrationConfirm(userId, username);
            
            const embed = new EmbedBuilder()
                .setColor('#00FF00')
                .setTitle('üéâ ƒêƒÇNG K√ù TH√ÄNH C√îNG!')
                .setDescription(`Ch√†o m·ª´ng **${username}** ƒë·∫øn v·ªõi th·∫ø gi·ªõi tu ti√™n!`)
                .addFields(
                    {
                        name: 'üèîÔ∏è C·∫£nh gi·ªõi',
                        value: 'Ph√†m Nh√¢n - Level 1',
                        inline: true
                    },
                    {
                        name: 'üí∞ T√†i s·∫£n',
                        value: '1,000 Coins',
                        inline: true
                    },
                    {
                        name: 'üéÅ Qu√† t√¢n th·ªß',
                        value: 'ƒê√£ ƒë∆∞·ª£c th√™m v√†o kho!',
                        inline: true
                    }
                )
                .setTimestamp();

            const actionRow = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('start_first_cultivation')
                        .setLabel('üßò‚Äç‚ôÇÔ∏è Tu luy·ªán l·∫ßn ƒë·∫ßu')
                        .setStyle(ButtonStyle.Success)
                );

            await interaction.update({ embeds: [embed], components: [actionRow] });
            
        } catch (error) {
            logger.error('Registration error:', error);
            await interaction.reply({ 
                content: '‚ùå L·ªói khi ƒëƒÉng k√Ω t√†i kho·∫£n!', 
                ephemeral: true 
            });
        }
    },

    async handleShopPurchase(interaction) {
        const itemType = interaction.customId.split('_')[1];
        const itemId = interaction.values ? interaction.values[0] : interaction.customId.split('_')[2];
        
        // This would handle shop purchases
        await interaction.reply({ 
            content: `üõí ƒêang x·ª≠ l√Ω mua ${itemId}...`, 
            ephemeral: true 
        });
    },

    async handleClaimDailyRewards(interaction) {
        const userId = interaction.user.id;
        const missionService = require('../services/missionService');
        
        const result = await missionService.claimDailyRewards(userId);
        
        if (result.success) {
            const embed = new EmbedBuilder()
                .setColor('#00FF00')
                .setTitle('üéÅ NH·∫¨N TH∆Ø·ªûNG TH√ÄNH C√îNG!')
                .setDescription('B·∫°n ƒë√£ nh·∫≠n ƒë∆∞·ª£c ph·∫ßn th∆∞·ªüng nhi·ªám v·ª• h√†ng ng√†y!')
                .addFields(
                    {
                        name: 'üí∞ Ph·∫ßn th∆∞·ªüng',
                        value: result.rewards.join('\n'),
                        inline: false
                    }
                )
                .setTimestamp();

            await interaction.update({ embeds: [embed], components: [] });
        } else {
            await interaction.reply({ 
                content: `‚ùå ${result.message}`, 
                ephemeral: true 
            });
        }
    },

    async handleClaimWeeklyRewards(interaction) {
        const userId = interaction.user.id;
        const missionService = require('../services/missionService');
        
        const result = await missionService.claimWeeklyRewards(userId);
        
        if (result.success) {
            const embed = new EmbedBuilder()
                .setColor('#00FF00')
                .setTitle('üéÅ NH·∫¨N TH∆Ø·ªûNG TU·∫¶N TH√ÄNH C√îNG!')
                .setDescription('B·∫°n ƒë√£ nh·∫≠n ƒë∆∞·ª£c ph·∫ßn th∆∞·ªüng nhi·ªám v·ª• h√†ng tu·∫ßn!')
                .addFields(
                    {
                        name: 'üíé Ph·∫ßn th∆∞·ªüng',
                        value: result.rewards.join('\n'),
                        inline: false
                    }
                )
                .setTimestamp();

            await interaction.update({ embeds: [embed], components: [] });
        } else {
            await interaction.reply({ 
                content: `‚ùå ${result.message}`, 
                ephemeral: true 
            });
        }
    },

    async handleRankingCategorySelect(interaction, category) {
        const bxhCommand = require('../commands/bxh');
        const mockMessage = {
            ...interaction,
            reply: interaction.update.bind(interaction),
            author: interaction.user,
            client: interaction.client
        };
        
        await bxhCommand.execute(mockMessage, [category]);
    },

    async handleHelpCategorySelect(interaction, category) {
        const hotroCommand = require('../commands/hotro');
        const mockMessage = {
            ...interaction,
            reply: interaction.update.bind(interaction),
            author: interaction.user,
            client: interaction.client
        };
        
        await hotroCommand.execute(mockMessage, [category]);
    },

    async handleItemPurchaseSelect(interaction, itemId) {
        const userId = interaction.user.id;
        const player = playerManager.getPlayer(userId);
        
        // Simple purchase logic - would be expanded in full implementation
        const itemPrice = 1000; // Placeholder
        
        if (player.coins >= itemPrice) {
            player.coins -= itemPrice;
            playerManager.addItem(userId, 'weapons', itemId, 1);
            playerManager.updatePlayer(userId, player);
            
            await interaction.update({ 
                content: `‚úÖ ƒê√£ mua ${itemId} th√†nh c√¥ng!`, 
                components: [] 
            });
        } else {
            await interaction.reply({ 
                content: '‚ùå Kh√¥ng ƒë·ªß coins!', 
                ephemeral: true 
            });
        }
    }
};

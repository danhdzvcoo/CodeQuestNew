const { EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, StringSelectMenuBuilder } = require('discord.js');
const playerManager = require('../player');
const logger = require('../utils/logger');

module.exports = {
    name: 'kho',
    description: 'Qu·∫£n l√Ω kho ƒë·ªì v√† trang b·ªã c·ªßa b·∫°n',
    
    async execute(message, args) {
        try {
            const userId = message.author.id;
            const player = playerManager.getPlayer(userId);
            
            // Check if player is banned
            if (player.banned) {
                const bannedEmbed = new EmbedBuilder()
                    .setColor('#FF0000')
                    .setTitle('üö´ T√†i kho·∫£n b·ªã c·∫•m')
                    .setDescription('B·∫°n ƒë√£ b·ªã c·∫•m s·ª≠ d·ª•ng bot. Li√™n h·ªá admin ƒë·ªÉ bi·∫øt th√™m chi ti·∫øt.')
                    .setTimestamp();
                
                return message.reply({ embeds: [bannedEmbed] });
            }

            const subCommand = args[0]?.toLowerCase();

            switch (subCommand) {
                case 'weapons':
                case 'vukhi':
                    return this.showWeaponsInventory(message, player);
                
                case 'armor':
                case 'giapao':
                    return this.showArmorInventory(message, player);
                
                case 'pills':
                case 'thuoc':
                    return this.showPillsInventory(message, player);
                
                case 'materials':
                case 'nguyenlieu':
                    return this.showMaterialsInventory(message, player);
                
                case 'equip':
                case 'trangbi':
                    return this.equipItem(message, args.slice(1), player);
                
                case 'unequip':
                case 'thaobo':
                    return this.unequipItem(message, args.slice(1), player);
                
                case 'use':
                case 'sudung':
                    return this.useItem(message, args.slice(1), player);
                
                case 'sort':
                case 'sapxep':
                    return this.sortInventory(message, args.slice(1), player);
                
                default:
                    return this.showInventoryOverview(message, player);
            }

        } catch (error) {
            logger.error('Error in kho command:', error);
            
            const errorEmbed = new EmbedBuilder()
                .setColor('#FF0000')
                .setTitle('‚ùå L·ªói h·ªá th·ªëng')
                .setDescription('ƒê√£ x·∫£y ra l·ªói khi truy c·∫≠p kho ƒë·ªì!')
                .setTimestamp();
            
            message.reply({ embeds: [errorEmbed] });
        }
    },

    async showInventoryOverview(message, player) {
        const totalItems = this.getTotalItems(player.inventory);
        const inventoryValue = this.calculateInventoryValue(player.inventory);
        const equipmentStats = this.getEquipmentStats(player.equipment);

        const overviewEmbed = new EmbedBuilder()
            .setColor('#4B0082')
            .setTitle('üéí KHO ƒê·ªí C√Å NH√ÇN')
            .setDescription(`**${message.author.username}** - Qu·∫£n l√Ω t√†i s·∫£n v√† trang b·ªã`)
            .addFields(
                {
                    name: 'üìä T·ªïng quan kho ƒë·ªì',
                    value: `**T·ªïng items:** ${totalItems.total}\n**Gi√° tr·ªã ∆∞·ªõc t√≠nh:** ${inventoryValue.toLocaleString()} coins\n**Slot ƒë√£ d√πng:** ${totalItems.slots}/1000`,
                    inline: true
                },
                {
                    name: 'üì¶ Ph√¢n lo·∫°i items',
                    value: `**V≈© kh√≠:** ${totalItems.weapons}\n**Gi√°p √°o:** ${totalItems.armor}\n**Pills:** ${totalItems.pills}\n**Nguy√™n li·ªáu:** ${totalItems.materials}`,
                    inline: true
                },
                {
                    name: '‚öîÔ∏è Trang b·ªã hi·ªán t·∫°i',
                    value: `**V≈© kh√≠:** ${player.equipment.weapon || 'Kh√¥ng c√≥'}\n**Gi√°p:** ${player.equipment.armor || 'Kh√¥ng c√≥'}\n**Ph·ª• ki·ªán:** ${player.equipment.accessory || 'Kh√¥ng c√≥'}`,
                    inline: true
                },
                {
                    name: 'üí™ Bonus t·ª´ trang b·ªã',
                    value: `**Attack:** +${equipmentStats.attack}\n**Defense:** +${equipmentStats.defense}\n**HP:** +${equipmentStats.hp}\n**Crit:** +${equipmentStats.crit}%`,
                    inline: true
                },
                {
                    name: 'üåü Items hi·∫øm nh·∫•t',
                    value: this.getRarestItems(player.inventory),
                    inline: true
                },
                {
                    name: '‚ö° Quick Actions',
                    value: '`!kho weapons` - Xem v≈© kh√≠\n`!kho armor` - Xem gi√°p √°o\n`!kho pills` - Xem thu·ªëc\n`!kho equip <item>` - Trang b·ªã\n`!kho use <item>` - S·ª≠ d·ª•ng',
                    inline: false
                }
            )
            .setThumbnail('https://cdn.discordapp.com/attachments/placeholder/inventory.png')
            .setFooter({ text: 'Tu Ti√™n Bot - H·ªá th·ªëng kho ƒë·ªì' })
            .setTimestamp();

        const actionRow = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('show_weapons_inventory')
                    .setLabel('‚öîÔ∏è V≈© kh√≠')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji('üó°Ô∏è'),
                new ButtonBuilder()
                    .setCustomId('show_armor_inventory')
                    .setLabel('üõ°Ô∏è Gi√°p √°o')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji('üëï'),
                new ButtonBuilder()
                    .setCustomId('show_pills_inventory')
                    .setLabel('üíä Pills')
                    .setStyle(ButtonStyle.Success)
                    .setEmoji('‚ö°')
            );

        const secondRow = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('show_materials_inventory')
                    .setLabel('üîÆ Nguy√™n li·ªáu')
                    .setStyle(ButtonStyle.Secondary)
                    .setEmoji('üåø'),
                new ButtonBuilder()
                    .setCustomId('auto_sort_inventory')
                    .setLabel('üìã S·∫Øp x·∫øp t·ª± ƒë·ªông')
                    .setStyle(ButtonStyle.Secondary)
                    .setEmoji('üîÑ'),
                new ButtonBuilder()
                    .setCustomId('inventory_statistics')
                    .setLabel('üìä Th·ªëng k√™ chi ti·∫øt')
                    .setStyle(ButtonStyle.Secondary)
                    .setEmoji('üìà')
            );

        message.reply({ 
            embeds: [overviewEmbed], 
            components: [actionRow, secondRow] 
        });
    },

    async showWeaponsInventory(message, player) {
        const weapons = player.inventory.weapons || {};
        const weaponList = Object.entries(weapons).filter(([id, quantity]) => quantity > 0);

        const weaponsEmbed = new EmbedBuilder()
            .setColor('#DC143C')
            .setTitle('‚öîÔ∏è KHO V≈® KH√ç')
            .setDescription(`**${message.author.username}** - B·ªô s∆∞u t·∫≠p v≈© kh√≠`)
            .addFields(
                {
                    name: 'üó°Ô∏è V≈© kh√≠ hi·ªán t·∫°i',
                    value: player.equipment.weapon || 'Kh√¥ng c√≥',
                    inline: true
                },
                {
                    name: 'üì¶ T·ªïng s·ªë v≈© kh√≠',
                    value: `${weaponList.length} lo·∫°i`,
                    inline: true
                },
                {
                    name: 'üí∞ Gi√° tr·ªã ∆∞·ªõc t√≠nh',
                    value: `${this.calculateCategoryValue(weapons, 'weapons').toLocaleString()} coins`,
                    inline: true
                }
            )
            .setThumbnail('https://cdn.discordapp.com/attachments/placeholder/weapons_inventory.png')
            .setFooter({ text: 'D√πng !kho equip <weapon_id> ƒë·ªÉ trang b·ªã' })
            .setTimestamp();

        if (weaponList.length === 0) {
            weaponsEmbed.addFields({
                name: 'üì≠ Kho tr·ªëng',
                value: 'B·∫°n ch∆∞a c√≥ v≈© kh√≠ n√†o. H√£y gh√© thƒÉm c·ª≠a h√†ng ƒë·ªÉ mua!',
                inline: false
            });
        } else {
            let weaponText = '';
            weaponList.forEach(([weaponId, quantity]) => {
                const weaponInfo = this.getItemInfo(weaponId, 'weapons');
                const equipped = player.equipment.weapon === weaponId ? '‚úÖ ' : '';
                weaponText += `${equipped}${weaponInfo.rarity} **${weaponInfo.name}** x${quantity}\n`;
                weaponText += `   Attack: +${weaponInfo.attack} | Crit: +${weaponInfo.crit}%\n`;
                weaponText += `   ID: \`${weaponId}\`\n\n`;
            });
            
            // Split long text into multiple fields if needed
            const chunks = this.chunkText(weaponText, 1024);
            chunks.forEach((chunk, index) => {
                weaponsEmbed.addFields({
                    name: index === 0 ? 'üó°Ô∏è Danh s√°ch v≈© kh√≠' : 'üó°Ô∏è Ti·∫øp t·ª•c...',
                    value: chunk,
                    inline: false
                });
            });
        }

        const actionRow = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('equip_best_weapon')
                    .setLabel('‚ö° Trang b·ªã t·ªët nh·∫•t')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji('üèÜ')
                    .setDisabled(weaponList.length === 0),
                new ButtonBuilder()
                    .setCustomId('compare_weapons')
                    .setLabel('‚öñÔ∏è So s√°nh v≈© kh√≠')
                    .setStyle(ButtonStyle.Secondary)
                    .setEmoji('üìä')
                    .setDisabled(weaponList.length < 2),
                new ButtonBuilder()
                    .setCustomId('sell_duplicate_weapons')
                    .setLabel('üí∞ B√°n duplicate')
                    .setStyle(ButtonStyle.Secondary)
                    .setEmoji('üóëÔ∏è')
            );

        message.reply({ embeds: [weaponsEmbed], components: [actionRow] });
    },

    async showArmorInventory(message, player) {
        const armors = player.inventory.armor || {};
        const armorList = Object.entries(armors).filter(([id, quantity]) => quantity > 0);

        const armorEmbed = new EmbedBuilder()
            .setColor('#4169E1')
            .setTitle('üõ°Ô∏è KHO GI√ÅP √ÅO')
            .setDescription(`**${message.author.username}** - B·ªô s∆∞u t·∫≠p gi√°p √°o`)
            .addFields(
                {
                    name: 'üëï Gi√°p hi·ªán t·∫°i',
                    value: player.equipment.armor || 'Kh√¥ng c√≥',
                    inline: true
                },
                {
                    name: 'üì¶ T·ªïng s·ªë gi√°p',
                    value: `${armorList.length} lo·∫°i`,
                    inline: true
                },
                {
                    name: 'üí∞ Gi√° tr·ªã ∆∞·ªõc t√≠nh',
                    value: `${this.calculateCategoryValue(armors, 'armor').toLocaleString()} coins`,
                    inline: true
                }
            )
            .setThumbnail('https://cdn.discordapp.com/attachments/placeholder/armor_inventory.png')
            .setFooter({ text: 'D√πng !kho equip <armor_id> ƒë·ªÉ trang b·ªã' })
            .setTimestamp();

        if (armorList.length === 0) {
            armorEmbed.addFields({
                name: 'üì≠ Kho tr·ªëng',
                value: 'B·∫°n ch∆∞a c√≥ gi√°p √°o n√†o. H√£y gh√© thƒÉm c·ª≠a h√†ng ƒë·ªÉ mua!',
                inline: false
            });
        } else {
            let armorText = '';
            armorList.forEach(([armorId, quantity]) => {
                const armorInfo = this.getItemInfo(armorId, 'armor');
                const equipped = player.equipment.armor === armorId ? '‚úÖ ' : '';
                armorText += `${equipped}${armorInfo.rarity} **${armorInfo.name}** x${quantity}\n`;
                armorText += `   Defense: +${armorInfo.defense} | HP: +${armorInfo.hp}\n`;
                armorText += `   ID: \`${armorId}\`\n\n`;
            });
            
            const chunks = this.chunkText(armorText, 1024);
            chunks.forEach((chunk, index) => {
                armorEmbed.addFields({
                    name: index === 0 ? 'üõ°Ô∏è Danh s√°ch gi√°p √°o' : 'üõ°Ô∏è Ti·∫øp t·ª•c...',
                    value: chunk,
                    inline: false
                });
            });
        }

        const actionRow = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('equip_best_armor')
                    .setLabel('‚ö° Trang b·ªã t·ªët nh·∫•t')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji('üèÜ')
                    .setDisabled(armorList.length === 0),
                new ButtonBuilder()
                    .setCustomId('create_armor_set')
                    .setLabel('üëî T·∫°o b·ªô gi√°p')
                    .setStyle(ButtonStyle.Secondary)
                    .setEmoji('‚ú®'),
                new ButtonBuilder()
                    .setCustomId('upgrade_armor')
                    .setLabel('‚¨ÜÔ∏è N√¢ng c·∫•p')
                    .setStyle(ButtonStyle.Secondary)
                    .setEmoji('üîß')
            );

        message.reply({ embeds: [armorEmbed], components: [actionRow] });
    },

    async showPillsInventory(message, player) {
        const pills = player.inventory.pills || {};
        const pillList = Object.entries(pills).filter(([id, quantity]) => quantity > 0);

        const pillsEmbed = new EmbedBuilder()
            .setColor('#9932CC')
            .setTitle('üíä KHO THU·ªêC')
            .setDescription(`**${message.author.username}** - B·ªô s∆∞u t·∫≠p pills v√† thu·ªëc`)
            .addFields(
                {
                    name: '‚ö° Hi·ªáu ·ª©ng ƒëang c√≥',
                    value: this.getActiveEffects(player) || 'Kh√¥ng c√≥',
                    inline: true
                },
                {
                    name: 'üì¶ T·ªïng s·ªë pills',
                    value: `${pillList.length} lo·∫°i`,
                    inline: true
                },
                {
                    name: 'üí∞ Gi√° tr·ªã ∆∞·ªõc t√≠nh',
                    value: `${this.calculateCategoryValue(pills, 'pills').toLocaleString()} coins`,
                    inline: true
                }
            )
            .setThumbnail('https://cdn.discordapp.com/attachments/placeholder/pills_inventory.png')
            .setFooter({ text: 'D√πng !kho use <pill_id> ƒë·ªÉ s·ª≠ d·ª•ng' })
            .setTimestamp();

        if (pillList.length === 0) {
            pillsEmbed.addFields({
                name: 'üì≠ Kho tr·ªëng',
                value: 'B·∫°n ch∆∞a c√≥ pill n√†o. H√£y gh√© thƒÉm c·ª≠a h√†ng ƒë·ªÉ mua!',
                inline: false
            });
        } else {
            let pillText = '';
            pillList.forEach(([pillId, quantity]) => {
                const pillInfo = this.getItemInfo(pillId, 'pills');
                pillText += `${pillInfo.rarity} **${pillInfo.name}** x${quantity}\n`;
                pillText += `   Effect: ${pillInfo.effect}\n`;
                pillText += `   Duration: ${pillInfo.duration} | Cooldown: ${pillInfo.cooldown}\n`;
                pillText += `   ID: \`${pillId}\`\n\n`;
            });
            
            const chunks = this.chunkText(pillText, 1024);
            chunks.forEach((chunk, index) => {
                pillsEmbed.addFields({
                    name: index === 0 ? 'üíä Danh s√°ch pills' : 'üíä Ti·∫øp t·ª•c...',
                    value: chunk,
                    inline: false
                });
            });
        }

        const actionRow = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('use_health_pill')
                    .setLabel('‚ù§Ô∏è D√πng Health Pill')
                    .setStyle(ButtonStyle.Success)
                    .setEmoji('üíä')
                    .setDisabled(!pills.health_pill),
                new ButtonBuilder()
                    .setCustomId('use_spirit_pill')
                    .setLabel('üîÆ D√πng Spirit Pill')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji('‚ö°')
                    .setDisabled(!pills.spirit_pill),
                new ButtonBuilder()
                    .setCustomId('auto_use_pills')
                    .setLabel('ü§ñ Auto s·ª≠ d·ª•ng')
                    .setStyle(ButtonStyle.Secondary)
                    .setEmoji('‚öôÔ∏è')
            );

        message.reply({ embeds: [pillsEmbed], components: [actionRow] });
    },

    async showMaterialsInventory(message, player) {
        const materials = player.inventory.materials || {};
        const materialList = Object.entries(materials).filter(([id, quantity]) => quantity > 0);

        const materialsEmbed = new EmbedBuilder()
            .setColor('#8FBC8F')
            .setTitle('üîÆ KHO NGUY√äN LI·ªÜU')
            .setDescription(`**${message.author.username}** - Nguy√™n li·ªáu ch·∫ø t·∫°o`)
            .addFields(
                {
                    name: '‚öíÔ∏è C√≥ th·ªÉ ch·∫ø t·∫°o',
                    value: this.getCraftableItems(materials),
                    inline: true
                },
                {
                    name: 'üì¶ T·ªïng s·ªë lo·∫°i',
                    value: `${materialList.length} lo·∫°i`,
                    inline: true
                },
                {
                    name: 'üí∞ Gi√° tr·ªã ∆∞·ªõc t√≠nh',
                    value: `${this.calculateCategoryValue(materials, 'materials').toLocaleString()} coins`,
                    inline: true
                }
            )
            .setThumbnail('https://cdn.discordapp.com/attachments/placeholder/materials_inventory.png')
            .setFooter({ text: 'D√πng nguy√™n li·ªáu ƒë·ªÉ ch·∫ø t·∫°o items m·∫°nh h∆°n!' })
            .setTimestamp();

        if (materialList.length === 0) {
            materialsEmbed.addFields({
                name: 'üì≠ Kho tr·ªëng',
                value: 'B·∫°n ch∆∞a c√≥ nguy√™n li·ªáu n√†o. H√£y gh√© thƒÉm c·ª≠a h√†ng ƒë·ªÉ mua!',
                inline: false
            });
        } else {
            let materialText = '';
            materialList.forEach(([materialId, quantity]) => {
                const materialInfo = this.getItemInfo(materialId, 'materials');
                materialText += `${materialInfo.rarity} **${materialInfo.name}** x${quantity}\n`;
                materialText += `   Type: ${materialInfo.type} | Uses: ${materialInfo.uses}\n`;
                materialText += `   ID: \`${materialId}\`\n\n`;
            });
            
            const chunks = this.chunkText(materialText, 1024);
            chunks.forEach((chunk, index) => {
                materialsEmbed.addFields({
                    name: index === 0 ? 'üîÆ Danh s√°ch nguy√™n li·ªáu' : 'üîÆ Ti·∫øp t·ª•c...',
                    value: chunk,
                    inline: false
                });
            });
        }

        const actionRow = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('show_crafting_recipes')
                    .setLabel('üìú C√¥ng th·ª©c ch·∫ø t·∫°o')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji('‚öíÔ∏è'),
                new ButtonBuilder()
                    .setCustomId('auto_craft_available')
                    .setLabel('üîÑ Ch·∫ø t·∫°o t·ª± ƒë·ªông')
                    .setStyle(ButtonStyle.Secondary)
                    .setEmoji('ü§ñ'),
                new ButtonBuilder()
                    .setCustomId('exchange_materials')
                    .setLabel('üîÑ ƒê·ªïi nguy√™n li·ªáu')
                    .setStyle(ButtonStyle.Secondary)
                    .setEmoji('‚ÜîÔ∏è')
            );

        message.reply({ embeds: [materialsEmbed], components: [actionRow] });
    },

    async equipItem(message, args, player) {
        if (args.length === 0) {
            const helpEmbed = new EmbedBuilder()
                .setColor('#FFA500')
                .setTitle('‚öîÔ∏è TRANG B·ªä V·∫¨T PH·∫®M')
                .setDescription('**C√∫ ph√°p:** `!kho equip <item_id>`')
                .addFields(
                    {
                        name: 'V√≠ d·ª•:',
                        value: '`!kho equip iron_sword`\n`!kho equip leather_armor`'
                    },
                    {
                        name: 'L∆∞u √Ω:',
                        value: 'Ch·ªâ c√≥ th·ªÉ trang b·ªã weapons v√† armor.\nV·∫≠t ph·∫©m ph·∫£i c√≥ trong kho ƒë·ªì.'
                    }
                );
            
            return message.reply({ embeds: [helpEmbed] });
        }

        const itemId = args[0].toLowerCase();
        
        // Check if player has the item
        const hasWeapon = player.inventory.weapons?.[itemId] > 0;
        const hasArmor = player.inventory.armor?.[itemId] > 0;
        
        if (!hasWeapon && !hasArmor) {
            return message.reply('‚ùå B·∫°n kh√¥ng c√≥ v·∫≠t ph·∫©m n√†y trong kho!');
        }

        let itemInfo, category, oldItem;
        
        if (hasWeapon) {
            itemInfo = this.getItemInfo(itemId, 'weapons');
            category = 'weapon';
            oldItem = player.equipment.weapon;
            player.equipment.weapon = itemId;
        } else {
            itemInfo = this.getItemInfo(itemId, 'armor');
            category = 'armor';
            oldItem = player.equipment.armor;
            player.equipment.armor = itemId;
        }

        // Update player stats based on equipment
        this.updatePlayerStatsFromEquipment(player);
        playerManager.updatePlayer(player.id, player);

        const successEmbed = new EmbedBuilder()
            .setColor('#00FF00')
            .setTitle('‚úÖ TRANG B·ªä TH√ÄNH C√îNG!')
            .setDescription(`B·∫°n ƒë√£ trang b·ªã **${itemInfo.name}**!`)
            .addFields(
                {
                    name: '‚öîÔ∏è V·∫≠t ph·∫©m m·ªõi',
                    value: `${itemInfo.rarity} ${itemInfo.name}`,
                    inline: true
                },
                {
                    name: 'üìä Bonus stats',
                    value: this.getItemBonusText(itemInfo),
                    inline: true
                },
                {
                    name: 'üîÑ Thay ƒë·ªïi',
                    value: oldItem ? `${oldItem} ‚Üí ${itemInfo.name}` : `Kh√¥ng c√≥ ‚Üí ${itemInfo.name}`,
                    inline: false
                }
            )
            .setTimestamp();

        message.reply({ embeds: [successEmbed] });
    },

    async unequipItem(message, args, player) {
        if (args.length === 0) {
            const helpEmbed = new EmbedBuilder()
                .setColor('#FFA500')
                .setTitle('üîß TH√ÅO B·ªé TRANG B·ªä')
                .setDescription('**C√∫ ph√°p:** `!kho unequip <weapon|armor>`')
                .addFields(
                    {
                        name: 'V√≠ d·ª•:',
                        value: '`!kho unequip weapon`\n`!kho unequip armor`'
                    }
                );
            
            return message.reply({ embeds: [helpEmbed] });
        }

        const itemType = args[0].toLowerCase();
        
        if (!['weapon', 'armor'].includes(itemType)) {
            return message.reply('‚ùå Ch·ªâ c√≥ th·ªÉ th√°o weapon ho·∫∑c armor!');
        }

        const currentItem = player.equipment[itemType];
        if (!currentItem) {
            return message.reply(`‚ùå B·∫°n kh√¥ng c√≥ ${itemType} n√†o ƒëang trang b·ªã!`);
        }

        player.equipment[itemType] = null;
        this.updatePlayerStatsFromEquipment(player);
        playerManager.updatePlayer(player.id, player);

        const successEmbed = new EmbedBuilder()
            .setColor('#00FF00')
            .setTitle('‚úÖ TH√ÅO B·ªé TH√ÄNH C√îNG!')
            .setDescription(`B·∫°n ƒë√£ th√°o b·ªè **${currentItem}**!`)
            .addFields({
                name: 'üìä Thay ƒë·ªïi stats',
                value: 'Stats t·ª´ trang b·ªã ƒë√£ ƒë∆∞·ª£c lo·∫°i b·ªè.',
                inline: false
            })
            .setTimestamp();

        message.reply({ embeds: [successEmbed] });
    },

    async useItem(message, args, player) {
        if (args.length === 0) {
            const helpEmbed = new EmbedBuilder()
                .setColor('#FFA500')
                .setTitle('üíä S·ª¨ D·ª§NG V·∫¨T PH·∫®M')
                .setDescription('**C√∫ ph√°p:** `!kho use <item_id> [quantity]`')
                .addFields(
                    {
                        name: 'V√≠ d·ª•:',
                        value: '`!kho use health_pill`\n`!kho use exp_pill 3`'
                    },
                    {
                        name: 'L∆∞u √Ω:',
                        value: 'Ch·ªâ c√≥ th·ªÉ s·ª≠ d·ª•ng pills v√† consumables.\nKi·ªÉm tra cooldown tr∆∞·ªõc khi d√πng.'
                    }
                );
            
            return message.reply({ embeds: [helpEmbed] });
        }

        const itemId = args[0].toLowerCase();
        const quantity = parseInt(args[1]) || 1;
        
        // Check if player has the item
        const hasPill = player.inventory.pills?.[itemId] >= quantity;
        
        if (!hasPill) {
            return message.reply('‚ùå B·∫°n kh√¥ng c√≥ ƒë·ªß pills n√†y trong kho!');
        }

        const pillInfo = this.getItemInfo(itemId, 'pills');
        if (!pillInfo) {
            return message.reply('‚ùå Kh√¥ng th·ªÉ s·ª≠ d·ª•ng v·∫≠t ph·∫©m n√†y!');
        }

        // Check cooldown
        const cooldownKey = `pill_cooldown_${itemId}`;
        const lastUsed = player[cooldownKey];
        if (lastUsed) {
            const cooldownTime = this.parseDuration(pillInfo.cooldown);
            const timeSince = Date.now() - new Date(lastUsed).getTime();
            
            if (timeSince < cooldownTime) {
                const remainingTime = Math.ceil((cooldownTime - timeSince) / 1000 / 60);
                return message.reply(`‚ùå Pills n√†y ƒëang cooldown! C√≤n ${remainingTime} ph√∫t.`);
            }
        }

        // Apply pill effects
        const effects = this.applyPillEffects(player, pillInfo, quantity);
        
        // Remove pills from inventory
        playerManager.removeItem(player.id, 'pills', itemId, quantity);
        
        // Set cooldown
        player[cooldownKey] = new Date().toISOString();
        playerManager.updatePlayer(player.id, player);

        const successEmbed = new EmbedBuilder()
            .setColor('#00FF00')
            .setTitle('‚úÖ S·ª¨ D·ª§NG TH√ÄNH C√îNG!')
            .setDescription(`B·∫°n ƒë√£ s·ª≠ d·ª•ng **${quantity}x ${pillInfo.name}**!`)
            .addFields(
                {
                    name: '‚ö° Hi·ªáu ·ª©ng',
                    value: effects.join('\n'),
                    inline: false
                },
                {
                    name: '‚è∞ Th·ªùi gian hi·ªáu l·ª±c',
                    value: pillInfo.duration,
                    inline: true
                },
                {
                    name: 'üïê Cooldown',
                    value: pillInfo.cooldown,
                    inline: true
                }
            )
            .setTimestamp();

        message.reply({ embeds: [successEmbed] });
    },

    // Helper methods
    getTotalItems(inventory) {
        let total = 0;
        let weapons = 0;
        let armor = 0;
        let pills = 0;
        let materials = 0;

        for (const category in inventory) {
            for (const itemId in inventory[category]) {
                const quantity = inventory[category][itemId];
                total += quantity;
                
                switch (category) {
                    case 'weapons': weapons += quantity; break;
                    case 'armor': armor += quantity; break;
                    case 'pills': pills += quantity; break;
                    case 'materials': materials += quantity; break;
                }
            }
        }

        return { total, weapons, armor, pills, materials, slots: total };
    },

    calculateInventoryValue(inventory) {
        let totalValue = 0;
        
        for (const category in inventory) {
            for (const itemId in inventory[category]) {
                const quantity = inventory[category][itemId];
                const itemInfo = this.getItemInfo(itemId, category);
                if (itemInfo && itemInfo.price) {
                    totalValue += itemInfo.price * quantity * 0.7; // 70% of shop price
                }
            }
        }
        
        return Math.floor(totalValue);
    },

    calculateCategoryValue(categoryItems, category) {
        let value = 0;
        
        for (const itemId in categoryItems) {
            const quantity = categoryItems[itemId];
            const itemInfo = this.getItemInfo(itemId, category);
            if (itemInfo && itemInfo.price) {
                value += itemInfo.price * quantity * 0.7;
            }
        }
        
        return Math.floor(value);
    },

    getEquipmentStats(equipment) {
        let stats = { attack: 0, defense: 0, hp: 0, crit: 0 };
        
        if (equipment.weapon) {
            const weaponInfo = this.getItemInfo(equipment.weapon, 'weapons');
            if (weaponInfo) {
                stats.attack += weaponInfo.attack || 0;
                stats.crit += weaponInfo.crit || 0;
            }
        }
        
        if (equipment.armor) {
            const armorInfo = this.getItemInfo(equipment.armor, 'armor');
            if (armorInfo) {
                stats.defense += armorInfo.defense || 0;
                stats.hp += armorInfo.hp || 0;
            }
        }
        
        return stats;
    },

    getRarestItems(inventory) {
        const rareItems = [];
        
        for (const category in inventory) {
            for (const itemId in inventory[category]) {
                const itemInfo = this.getItemInfo(itemId, category);
                if (itemInfo && (itemInfo.rarity === 'üü°' || itemInfo.rarity === 'üü†')) {
                    rareItems.push(`${itemInfo.rarity} ${itemInfo.name}`);
                }
            }
        }
        
        return rareItems.length > 0 ? rareItems.slice(0, 3).join('\n') : 'Kh√¥ng c√≥ items hi·∫øm';
    },

    getActiveEffects(player) {
        const effects = [];
        const now = Date.now();
        
        // Check for active pill effects (this would need to be tracked in player data)
        // For now, return placeholder
        return effects.length > 0 ? effects.join('\n') : null;
    },

    getCraftableItems(materials) {
        // This would check against crafting recipes
        // For now, return placeholder
        const count = Object.keys(materials).length;
        return count > 5 ? `${Math.floor(count / 3)} items` : 'C·∫ßn th√™m nguy√™n li·ªáu';
    },

    getItemInfo(itemId, category) {
        // This should reference the shop items or a separate items database
        // For now, return basic info based on common items
        const itemDatabase = {
            weapons: {
                'wooden_sword': { name: 'Wooden Sword', rarity: '‚ö™', attack: 20, crit: 2, price: 500 },
                'iron_sword': { name: 'Iron Sword', rarity: 'üü¢', attack: 50, crit: 5, price: 2000 },
                'steel_blade': { name: 'Steel Blade', rarity: 'üîµ', attack: 120, crit: 8, price: 8000 }
            },
            armor: {
                'cloth_robe': { name: 'Cloth Robe', rarity: '‚ö™', defense: 15, hp: 20, price: 400 },
                'leather_armor': { name: 'Leather Armor', rarity: 'üü¢', defense: 35, hp: 50, price: 1500 },
                'iron_plate': { name: 'Iron Plate', rarity: 'üîµ', defense: 80, hp: 100, price: 6000 }
            },
            pills: {
                'health_pill': { name: 'Health Pill', rarity: '‚ö™', effect: '+100 HP', duration: '1h', cooldown: '30m', price: 50 },
                'spirit_pill': { name: 'Spirit Pill', rarity: 'üü¢', effect: '+50 Spirit', duration: '1h', cooldown: '30m', price: 100 },
                'exp_pill': { name: 'EXP Pill', rarity: 'üîµ', effect: '+500 EXP', duration: 'Instant', cooldown: '1h', price: 1000 }
            },
            materials: {
                'iron_ore': { name: 'Iron Ore', rarity: 'üü¢', type: 'Metal', uses: 'Weapon crafting', price: 10 },
                'spirit_herb': { name: 'Spirit Herb', rarity: 'üîµ', type: 'Plant', uses: 'Pill creation', price: 50 }
            }
        };
        
        return itemDatabase[category]?.[itemId] || { name: 'Unknown Item', rarity: '‚ö™', price: 0 };
    },

    getItemBonusText(itemInfo) {
        const bonuses = [];
        if (itemInfo.attack) bonuses.push(`Attack: +${itemInfo.attack}`);
        if (itemInfo.defense) bonuses.push(`Defense: +${itemInfo.defense}`);
        if (itemInfo.hp) bonuses.push(`HP: +${itemInfo.hp}`);
        if (itemInfo.crit) bonuses.push(`Crit: +${itemInfo.crit}%`);
        return bonuses.join('\n') || 'Kh√¥ng c√≥ bonus';
    },

    updatePlayerStatsFromEquipment(player) {
        // Reset to base stats and reapply equipment bonuses
        const equipmentStats = this.getEquipmentStats(player.equipment);
        
        // This would need to track base stats vs equipment stats
        // For now, just update the current stats
        player.attack = Math.max(50, player.attack); // Base attack
        player.defense = Math.max(50, player.defense); // Base defense
        
        // Add equipment bonuses
        player.attack += equipmentStats.attack;
        player.defense += equipmentStats.defense;
        player.maxHealth += equipmentStats.hp;
        player.critChance += equipmentStats.crit;
    },

    applyPillEffects(player, pillInfo, quantity) {
        const effects = [];
        
        switch (pillInfo.effect) {
            case '+100 HP':
                const healthGain = 100 * quantity;
                player.health = Math.min(player.maxHealth, player.health + healthGain);
                effects.push(`+${healthGain} HP`);
                break;
                
            case '+50 Spirit':
                const spiritGain = 50 * quantity;
                player.spirit = Math.min(player.maxSpirit, player.spirit + spiritGain);
                effects.push(`+${spiritGain} Spirit`);
                break;
                
            case '+500 EXP':
                const expGain = 500 * quantity;
                playerManager.addExp(player.id, expGain);
                effects.push(`+${expGain} EXP`);
                break;
                
            default:
                effects.push('Hi·ªáu ·ª©ng kh√¥ng x√°c ƒë·ªãnh');
        }
        
        return effects;
    },

    parseDuration(duration) {
        const match = duration.match(/(\d+)([hm])/);
        if (!match) return 0;
        
        const value = parseInt(match[1]);
        const unit = match[2];
        
        return unit === 'h' ? value * 60 * 60 * 1000 : value * 60 * 1000;
    },

    chunkText(text, maxLength) {
        const chunks = [];
        let currentChunk = '';
        
        const lines = text.split('\n');
        for (const line of lines) {
            if (currentChunk.length + line.length > maxLength) {
                chunks.push(currentChunk);
                currentChunk = line;
            } else {
                currentChunk += (currentChunk ? '\n' : '') + line;
            }
        }
        
        if (currentChunk) chunks.push(currentChunk);
        return chunks;
    }
};

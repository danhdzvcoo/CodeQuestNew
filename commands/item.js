const { EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, StringSelectMenuBuilder } = require('discord.js');
const playerManager = require('../player');
const logger = require('../utils/logger');

module.exports = {
    name: 'item',
    description: 'Xem th√¥ng tin chi ti·∫øt v·ªÅ v·∫≠t ph·∫©m v√† qu·∫£n l√Ω items',
    
    async execute(message, args) {
        try {
            const userId = message.author.id;
            const player = playerManager.getPlayer(userId);
            
            // Check if player is banned
            if (player.banned) {
                const bannedEmbed = new EmbedBuilder()
                    .setColor('#FF0000')
                    .setTitle('üö´ T√†i kho·∫£n b·ªã c·∫•m')
                    .setDescription('B·∫°n ƒë√£ b·ªã c·∫•m s·ª≠ d·ª•ng bot. Li√™n h·ªá admin ƒë·ªÉ bi·∫øt th√™m chi ti·∫øt.')
                    .setTimestamp();
                
                return message.reply({ embeds: [bannedEmbed] });
            }

            const subCommand = args[0]?.toLowerCase();

            switch (subCommand) {
                case 'info':
                case 'thongtin':
                    return this.showItemInfo(message, args.slice(1));
                
                case 'compare':
                case 'sosanh':
                    return this.compareItems(message, args.slice(1));
                
                case 'craft':
                case 'chetao':
                    return this.craftItem(message, args.slice(1), player);
                
                case 'upgrade':
                case 'nangcap':
                    return this.upgradeItem(message, args.slice(1), player);
                
                case 'enchant':
                case 'phuphuy':
                    return this.enchantItem(message, args.slice(1), player);
                
                case 'dismantle':
                case 'thaodo':
                    return this.dismantleItem(message, args.slice(1), player);
                
                case 'recipes':
                case 'congthuc':
                    return this.showCraftingRecipes(message, player);
                
                default:
                    return this.showItemMenu(message, player);
            }

        } catch (error) {
            logger.error('Error in item command:', error);
            
            const errorEmbed = new EmbedBuilder()
                .setColor('#FF0000')
                .setTitle('‚ùå L·ªói h·ªá th·ªëng')
                .setDescription('ƒê√£ x·∫£y ra l·ªói khi th·ª±c hi·ªán l·ªánh item!')
                .setTimestamp();
            
            message.reply({ embeds: [errorEmbed] });
        }
    },

    async showItemMenu(message, player) {
        const craftableItems = this.getCraftableItemsCount(player);
        const upgradableItems = this.getUpgradableItemsCount(player);
        const enchantableItems = this.getEnchantableItemsCount(player);

        const menuEmbed = new EmbedBuilder()
            .setColor('#8A2BE2')
            .setTitle('üîß QU·∫¢N L√ù V·∫¨T PH·∫®M')
            .setDescription(`**${message.author.username}** - Ch·∫ø t·∫°o, n√¢ng c·∫•p v√† qu·∫£n l√Ω items`)
            .addFields(
                {
                    name: '‚öíÔ∏è Ch·∫ø t·∫°o',
                    value: `**C√≥ th·ªÉ ch·∫ø t·∫°o:** ${craftableItems} items\n**Recipes m·ªü kh√≥a:** ${this.getUnlockedRecipes(player)}\n**Th√†nh c√¥ng rate:** 95%`,
                    inline: true
                },
                {
                    name: '‚¨ÜÔ∏è N√¢ng c·∫•p',
                    value: `**C√≥ th·ªÉ n√¢ng c·∫•p:** ${upgradableItems} items\n**Max level:** +15\n**Success rate:** 80%`,
                    inline: true
                },
                {
                    name: '‚ú® Ph√π ph√©p',
                    value: `**C√≥ th·ªÉ enchant:** ${enchantableItems} items\n**Enchants available:** ${this.getAvailableEnchants(player)}\n**Success rate:** 60%`,
                    inline: true
                },
                {
                    name: 'üîç T√≠nh nƒÉng c√≥ s·∫µn',
                    value: '‚Ä¢ **Item Info:** Xem chi ti·∫øt v·∫≠t ph·∫©m\n‚Ä¢ **Compare:** So s√°nh 2 items\n‚Ä¢ **Craft:** Ch·∫ø t·∫°o items m·ªõi\n‚Ä¢ **Upgrade:** N√¢ng c·∫•p stats\n‚Ä¢ **Enchant:** Th√™m thu·ªôc t√≠nh ƒë·∫∑c bi·ªát\n‚Ä¢ **Dismantle:** Th√°o d·ª° ƒë·ªÉ l·∫•y nguy√™n li·ªáu',
                    inline: false
                },
                {
                    name: 'üìö H·ªá th·ªëng ch·∫ø t·∫°o',
                    value: '**Weapons:** Sword, Spear, Bow, Staff\n**Armor:** Robe, Plate, Leather\n**Accessories:** Ring, Amulet, Bracelet\n**Consumables:** Pills, Potions, Scrolls',
                    inline: true
                },
                {
                    name: '‚≠ê Item Rarity System',
                    value: '‚ö™ **Common** - Base stats\nüü¢ **Uncommon** - +20% stats\nüîµ **Rare** - +50% stats\nüü£ **Epic** - +100% stats\nüü† **Legendary** - +200% stats\nüü° **Mythic** - +500% stats',
                    inline: true
                }
            )
            .setThumbnail('https://cdn.discordapp.com/attachments/placeholder/item_crafting.png')
            .setFooter({ text: 'Tu Ti√™n Bot - Item Management System' })
            .setTimestamp();

        const actionRow = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('show_crafting_recipes')
                    .setLabel('üìú C√¥ng th·ª©c ch·∫ø t·∫°o')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji('‚öíÔ∏è'),
                new ButtonBuilder()
                    .setCustomId('quick_craft')
                    .setLabel('‚ö° Ch·∫ø t·∫°o nhanh')
                    .setStyle(ButtonStyle.Success)
                    .setEmoji('üî•'),
                new ButtonBuilder()
                    .setCustomId('upgrade_items')
                    .setLabel('‚¨ÜÔ∏è N√¢ng c·∫•p')
                    .setStyle(ButtonStyle.Secondary)
                    .setEmoji('üìà')
            );

        const secondRow = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('enchant_items')
                    .setLabel('‚ú® Ph√π ph√©p')
                    .setStyle(ButtonStyle.Secondary)
                    .setEmoji('üîÆ'),
                new ButtonBuilder()
                    .setCustomId('item_analyzer')
                    .setLabel('üî¨ Ph√¢n t√≠ch item')
                    .setStyle(ButtonStyle.Secondary)
                    .setEmoji('üß™'),
                new ButtonBuilder()
                    .setCustomId('item_market_prices')
                    .setLabel('üí∞ Gi√° th·ªã tr∆∞·ªùng')
                    .setStyle(ButtonStyle.Secondary)
                    .setEmoji('üìä')
            );

        message.reply({ 
            embeds: [menuEmbed], 
            components: [actionRow, secondRow] 
        });
    },

    async showItemInfo(message, args) {
        if (args.length === 0) {
            const helpEmbed = new EmbedBuilder()
                .setColor('#FFA500')
                .setTitle('üîç TH√îNG TIN V·∫¨T PH·∫®M')
                .setDescription('**C√∫ ph√°p:** `!item info <item_id>`')
                .addFields(
                    {
                        name: 'V√≠ d·ª•:',
                        value: '`!item info iron_sword`\n`!item info health_pill`\n`!item info dragon_scale`'
                    },
                    {
                        name: 'L∆∞u √Ω:',
                        value: 'C√≥ th·ªÉ xem th√¥ng tin m·ªçi item trong game, k·ªÉ c·∫£ ch∆∞a s·ªü h·ªØu.'
                    }
                );
            
            return message.reply({ embeds: [helpEmbed] });
        }

        const itemId = args[0].toLowerCase();
        const itemInfo = this.getDetailedItemInfo(itemId);

        if (!itemInfo) {
            return message.reply('‚ùå Kh√¥ng t√¨m th·∫•y v·∫≠t ph·∫©m n√†y!');
        }

        const infoEmbed = new EmbedBuilder()
            .setColor(this.getRarityColor(itemInfo.rarity))
            .setTitle(`${itemInfo.rarity} ${itemInfo.name.toUpperCase()}`)
            .setDescription(itemInfo.description || 'M·ªôt v·∫≠t ph·∫©m trong th·∫ø gi·ªõi tu ti√™n.')
            .addFields(
                {
                    name: 'üìä Th·ªëng k√™ c∆° b·∫£n',
                    value: this.getItemStatsText(itemInfo),
                    inline: true
                },
                {
                    name: 'üí∞ Gi√° tr·ªã',
                    value: `**Gi√° mua:** ${itemInfo.price?.toLocaleString() || 'N/A'} coins\n**Gi√° b√°n:** ${Math.floor((itemInfo.price || 0) * 0.7).toLocaleString()} coins\n**ƒê·ªô hi·∫øm:** ${this.getRarityName(itemInfo.rarity)}`,
                    inline: true
                },
                {
                    name: 'üèîÔ∏è Y√™u c·∫ßu',
                    value: `**Min Level:** ${itemInfo.minLevel || 1}\n**Min Realm:** ${itemInfo.minRealm || 'Ph√†m Nh√¢n'}\n**Class Req:** ${itemInfo.classReq || 'All'}`,
                    inline: true
                }
            )
            .setThumbnail(itemInfo.imageUrl || 'https://cdn.discordapp.com/attachments/placeholder/item_generic.png')
            .setFooter({ text: `Item ID: ${itemId} | Category: ${itemInfo.category}` })
            .setTimestamp();

        // Add category-specific information
        if (itemInfo.category === 'weapons') {
            infoEmbed.addFields(
                {
                    name: '‚öîÔ∏è Weapon Stats',
                    value: `**Attack:** ${itemInfo.attack}\n**Crit Chance:** ${itemInfo.crit}%\n**Weapon Type:** ${itemInfo.weaponType}\n**Durability:** ${itemInfo.durability || 100}/100`,
                    inline: true
                },
                {
                    name: 'üéØ Special Effects',
                    value: itemInfo.specialEffects?.join('\n') || 'Kh√¥ng c√≥ hi·ªáu ·ª©ng ƒë·∫∑c bi·ªát',
                    inline: true
                }
            );
        } else if (itemInfo.category === 'armor') {
            infoEmbed.addFields(
                {
                    name: 'üõ°Ô∏è Armor Stats',
                    value: `**Defense:** ${itemInfo.defense}\n**HP Bonus:** ${itemInfo.hp}\n**Armor Type:** ${itemInfo.armorType}\n**Weight:** ${itemInfo.weight || 'Light'}`,
                    inline: true
                },
                {
                    name: 'üõ°Ô∏è Resistances',
                    value: itemInfo.resistances?.join('\n') || 'Kh√¥ng c√≥ kh√°ng t√≠nh',
                    inline: true
                }
            );
        } else if (itemInfo.category === 'pills') {
            infoEmbed.addFields(
                {
                    name: 'üíä Pill Effects',
                    value: `**Primary Effect:** ${itemInfo.effect}\n**Duration:** ${itemInfo.duration}\n**Cooldown:** ${itemInfo.cooldown}\n**Stack Limit:** ${itemInfo.stackLimit || 1}`,
                    inline: true
                },
                {
                    name: '‚ö†Ô∏è Side Effects',
                    value: itemInfo.sideEffects?.join('\n') || 'Kh√¥ng c√≥ t√°c d·ª•ng ph·ª•',
                    inline: true
                }
            );
        }

        // Add crafting/upgrade information
        if (itemInfo.craftable) {
            const recipe = this.getCraftingRecipe(itemId);
            if (recipe) {
                infoEmbed.addFields({
                    name: '‚öíÔ∏è C√¥ng th·ª©c ch·∫ø t·∫°o',
                    value: recipe.materials.map(m => `${m.name} x${m.quantity}`).join('\n'),
                    inline: false
                });
            }
        }

        if (itemInfo.upgradable) {
            infoEmbed.addFields({
                name: '‚¨ÜÔ∏è N√¢ng c·∫•p',
                value: `**Max Level:** +${itemInfo.maxUpgrade || 15}\n**Current Enhancement:** None\n**Next Upgrade Cost:** ${this.getUpgradeCost(itemInfo, 1).toLocaleString()} coins`,
                inline: false
            });
        }

        const actionRow = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId(`compare_similar_items_${itemId}`)
                    .setLabel('‚öñÔ∏è So s√°nh t∆∞∆°ng t·ª±')
                    .setStyle(ButtonStyle.Secondary)
                    .setEmoji('üìä'),
                new ButtonBuilder()
                    .setCustomId(`show_item_history_${itemId}`)
                    .setLabel('üìú L·ªãch s·ª≠ item')
                    .setStyle(ButtonStyle.Secondary)
                    .setEmoji('üìà'),
                new ButtonBuilder()
                    .setCustomId(`item_wiki_${itemId}`)
                    .setLabel('üìö Wiki')
                    .setStyle(ButtonStyle.Secondary)
                    .setEmoji('üîç')
            );

        message.reply({ embeds: [infoEmbed], components: [actionRow] });
    },

    async compareItems(message, args) {
        if (args.length < 2) {
            const helpEmbed = new EmbedBuilder()
                .setColor('#FFA500')
                .setTitle('‚öñÔ∏è SO S√ÅNH V·∫¨T PH·∫®M')
                .setDescription('**C√∫ ph√°p:** `!item compare <item1_id> <item2_id>`')
                .addFields(
                    {
                        name: 'V√≠ d·ª•:',
                        value: '`!item compare iron_sword steel_blade`\n`!item compare leather_armor iron_plate`'
                    }
                );
            
            return message.reply({ embeds: [helpEmbed] });
        }

        const item1Id = args[0].toLowerCase();
        const item2Id = args[1].toLowerCase();

        const item1 = this.getDetailedItemInfo(item1Id);
        const item2 = this.getDetailedItemInfo(item2Id);

        if (!item1 || !item2) {
            return message.reply('‚ùå M·ªôt ho·∫∑c c·∫£ hai v·∫≠t ph·∫©m kh√¥ng t·ªìn t·∫°i!');
        }

        if (item1.category !== item2.category) {
            return message.reply('‚ùå Ch·ªâ c√≥ th·ªÉ so s√°nh items c√πng lo·∫°i!');
        }

        const compareEmbed = new EmbedBuilder()
            .setColor('#4169E1')
            .setTitle('‚öñÔ∏è SO S√ÅNH V·∫¨T PH·∫®M')
            .setDescription(`**${item1.name}** vs **${item2.name}**`)
            .addFields(
                {
                    name: `${item1.rarity} ${item1.name}`,
                    value: this.getComparisonText(item1),
                    inline: true
                },
                {
                    name: 'üÜö',
                    value: this.getComparisonDifference(item1, item2),
                    inline: true
                },
                {
                    name: `${item2.rarity} ${item2.name}`,
                    value: this.getComparisonText(item2),
                    inline: true
                }
            )
            .setFooter({ text: 'Xanh = t·ªët h∆°n, ƒê·ªè = k√©m h∆°n' })
            .setTimestamp();

        // Add overall recommendation
        const recommendation = this.getRecommendation(item1, item2);
        compareEmbed.addFields({
            name: 'üí° Khuy·∫øn ngh·ªã',
            value: recommendation,
            inline: false
        });

        const actionRow = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId(`detailed_comparison_${item1Id}_${item2Id}`)
                    .setLabel('üìä So s√°nh chi ti·∫øt')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji('üî¨'),
                new ButtonBuilder()
                    .setCustomId(`find_similar_items_${item1.category}`)
                    .setLabel('üîç T√¨m items t∆∞∆°ng t·ª±')
                    .setStyle(ButtonStyle.Secondary)
                    .setEmoji('üìã'),
                new ButtonBuilder()
                    .setCustomId(`market_price_comparison_${item1Id}_${item2Id}`)
                    .setLabel('üí∞ So s√°nh gi√°')
                    .setStyle(ButtonStyle.Secondary)
                    .setEmoji('üíπ')
            );

        message.reply({ embeds: [compareEmbed], components: [actionRow] });
    },

    async showCraftingRecipes(message, player) {
        const availableRecipes = this.getAvailableRecipes(player);
        const lockedRecipes = this.getLockedRecipes(player);

        const recipesEmbed = new EmbedBuilder()
            .setColor('#8B4513')
            .setTitle('üìú C√îNG TH·ª®C CHE T·∫†O')
            .setDescription(`**${message.author.username}** - Danh s√°ch c√¥ng th·ª©c`)
            .addFields(
                {
                    name: 'üìä Th·ªëng k√™',
                    value: `**ƒê√£ m·ªü kh√≥a:** ${availableRecipes.length}\n**Ch∆∞a m·ªü kh√≥a:** ${lockedRecipes.length}\n**Crafting Level:** ${this.getCraftingLevel(player)}`,
                    inline: true
                },
                {
                    name: 'üí∞ T√†i nguy√™n',
                    value: `**Coins:** ${player.coins.toLocaleString()}\n**Materials:** ${Object.keys(player.inventory.materials || {}).length} lo·∫°i`,
                    inline: true
                },
                {
                    name: 'üî• Success Rate',
                    value: `**Weapons:** 95%\n**Armor:** 90%\n**Pills:** 85%\n**Accessories:** 80%`,
                    inline: true
                }
            )
            .setThumbnail('https://cdn.discordapp.com/attachments/placeholder/crafting_recipes.png')
            .setFooter({ text: 'Ch·∫ø t·∫°o ƒë·ªÉ t·∫°o ra items m·∫°nh h∆°n!' })
            .setTimestamp();

        // Show available recipes by category
        const categories = ['weapons', 'armor', 'pills', 'accessories'];
        
        categories.forEach(category => {
            const categoryRecipes = availableRecipes.filter(r => r.category === category);
            if (categoryRecipes.length > 0) {
                let recipeText = '';
                categoryRecipes.slice(0, 5).forEach(recipe => {
                    const canCraft = this.canCraftItem(player, recipe);
                    const status = canCraft ? '‚úÖ' : '‚ùå';
                    recipeText += `${status} **${recipe.result.name}** ${recipe.result.rarity}\n`;
                    recipeText += `   ${recipe.materials.map(m => `${m.name} x${m.quantity}`).join(', ')}\n\n`;
                });
                
                recipesEmbed.addFields({
                    name: `${this.getCategoryEmoji(category)} ${category.charAt(0).toUpperCase() + category.slice(1)}`,
                    value: recipeText,
                    inline: false
                });
            }
        });

        const selectMenu = new StringSelectMenuBuilder()
            .setCustomId('select_recipe_to_craft')
            .setPlaceholder('Ch·ªçn c√¥ng th·ª©c ƒë·ªÉ ch·∫ø t·∫°o...')
            .addOptions(
                availableRecipes.slice(0, 25).map(recipe => ({
                    label: recipe.result.name,
                    description: `${recipe.materials.length} materials needed`,
                    value: recipe.id,
                    emoji: this.getCategoryEmoji(recipe.category)
                }))
            );

        const actionRow = new ActionRowBuilder().addComponents(selectMenu);

        const buttonRow = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('show_locked_recipes')
                    .setLabel('üîí C√¥ng th·ª©c ch∆∞a m·ªü kh√≥a')
                    .setStyle(ButtonStyle.Secondary)
                    .setEmoji('üìã'),
                new ButtonBuilder()
                    .setCustomId('auto_craft_queue')
                    .setLabel('ü§ñ H√†ng ƒë·ª£i ch·∫ø t·∫°o')
                    .setStyle(ButtonStyle.Secondary)
                    .setEmoji('‚öôÔ∏è'),
                new ButtonBuilder()
                    .setCustomId('crafting_calculator')
                    .setLabel('üßÆ M√°y t√≠nh ch·∫ø t·∫°o')
                    .setStyle(ButtonStyle.Secondary)
                    .setEmoji('üìä')
            );

        message.reply({ 
            embeds: [recipesEmbed], 
            components: [actionRow, buttonRow] 
        });
    },

    async craftItem(message, args, player) {
        if (args.length === 0) {
            return this.showCraftingRecipes(message, player);
        }

        const recipeId = args[0].toLowerCase();
        const quantity = parseInt(args[1]) || 1;

        if (quantity <= 0 || quantity > 10) {
            return message.reply('‚ùå S·ªë l∆∞·ª£ng ph·∫£i t·ª´ 1-10!');
        }

        const recipe = this.getCraftingRecipe(recipeId);
        if (!recipe) {
            return message.reply('‚ùå Kh√¥ng t√¨m th·∫•y c√¥ng th·ª©c n√†y!');
        }

        // Check if player has unlocked this recipe
        if (!this.hasRecipeUnlocked(player, recipeId)) {
            return message.reply('‚ùå B·∫°n ch∆∞a m·ªü kh√≥a c√¥ng th·ª©c n√†y!');
        }

        // Check materials
        const canCraft = this.canCraftItem(player, recipe, quantity);
        if (!canCraft.success) {
            return message.reply(`‚ùå ${canCraft.message}`);
        }

        // Calculate success chance
        const successChance = this.calculateCraftingSuccess(player, recipe);
        
        const confirmEmbed = new EmbedBuilder()
            .setColor('#8B4513')
            .setTitle('‚öíÔ∏è X√ÅC NH·∫¨N CH·∫æ T·∫†O')
            .setDescription(`B·∫°n c√≥ mu·ªën ch·∫ø t·∫°o **${quantity}x ${recipe.result.name}**?`)
            .addFields(
                {
                    name: 'üìã Nguy√™n li·ªáu c·∫ßn thi·∫øt',
                    value: recipe.materials.map(m => `${m.name} x${m.quantity * quantity}`).join('\n'),
                    inline: true
                },
                {
                    name: 'üí∞ Chi ph√≠',
                    value: `${(recipe.cost * quantity).toLocaleString()} coins`,
                    inline: true
                },
                {
                    name: 'üìä T·ª∑ l·ªá th√†nh c√¥ng',
                    value: `${successChance}%`,
                    inline: true
                },
                {
                    name: 'üéÅ K·∫øt qu·∫£ (n·∫øu th√†nh c√¥ng)',
                    value: `${recipe.result.rarity} **${recipe.result.name}** x${quantity}`,
                    inline: false
                }
            )
            .setTimestamp();

        const actionRow = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId(`confirm_craft_${recipeId}_${quantity}`)
                    .setLabel('‚úÖ X√°c nh·∫≠n ch·∫ø t·∫°o')
                    .setStyle(ButtonStyle.Success)
                    .setEmoji('‚öíÔ∏è'),
                new ButtonBuilder()
                    .setCustomId('cancel_craft')
                    .setLabel('‚ùå H·ªßy b·ªè')
                    .setStyle(ButtonStyle.Danger)
                    .setEmoji('üö´')
            );

        message.reply({ embeds: [confirmEmbed], components: [actionRow] });
    },

    async upgradeItem(message, args, player) {
        if (args.length === 0) {
            const helpEmbed = new EmbedBuilder()
                .setColor('#FFA500')
                .setTitle('‚¨ÜÔ∏è N√ÇNG C·∫§P V·∫¨T PH·∫®M')
                .setDescription('**C√∫ ph√°p:** `!item upgrade <item_id> [level]`')
                .addFields(
                    {
                        name: 'V√≠ d·ª•:',
                        value: '`!item upgrade iron_sword`\n`!item upgrade iron_sword 3`'
                    },
                    {
                        name: 'L∆∞u √Ω:',
                        value: 'Item ph·∫£i c√≥ trong inventory v√† c√≥ th·ªÉ n√¢ng c·∫•p.\nM·ªói level tƒÉng 10% stats base.'
                    }
                );
            
            return message.reply({ embeds: [helpEmbed] });
        }

        const itemId = args[0].toLowerCase();
        const targetLevel = parseInt(args[1]) || 1;

        // Check if player has the item
        const hasItem = this.playerHasUpgradableItem(player, itemId);
        if (!hasItem.success) {
            return message.reply(`‚ùå ${hasItem.message}`);
        }

        const itemInfo = this.getDetailedItemInfo(itemId);
        const currentLevel = this.getItemUpgradeLevel(player, itemId);
        const maxLevel = itemInfo.maxUpgrade || 15;

        if (currentLevel >= maxLevel) {
            return message.reply('‚ùå Item n√†y ƒë√£ ƒë·∫°t c·∫•p ƒë·ªô t·ªëi ƒëa!');
        }

        if (targetLevel <= currentLevel || targetLevel > maxLevel) {
            return message.reply(`‚ùå Level n√¢ng c·∫•p ph·∫£i t·ª´ ${currentLevel + 1} ƒë·∫øn ${maxLevel}!`);
        }

        const upgradeCost = this.getUpgradeCost(itemInfo, targetLevel - currentLevel);
        const successChance = this.calculateUpgradeSuccess(currentLevel, targetLevel);

        const upgradeEmbed = new EmbedBuilder()
            .setColor('#FF6347')
            .setTitle('‚¨ÜÔ∏è N√ÇNG C·∫§P V·∫¨T PH·∫®M')
            .setDescription(`N√¢ng c·∫•p **${itemInfo.name}** t·ª´ +${currentLevel} l√™n +${targetLevel}`)
            .addFields(
                {
                    name: 'üí∞ Chi ph√≠',
                    value: `${upgradeCost.toLocaleString()} coins`,
                    inline: true
                },
                {
                    name: 'üìä T·ª∑ l·ªá th√†nh c√¥ng',
                    value: `${successChance}%`,
                    inline: true
                },
                {
                    name: '‚ö†Ô∏è R·ªßi ro',
                    value: successChance < 50 ? 'C√≥ th·ªÉ h·ªèng item' : 'An to√†n',
                    inline: true
                },
                {
                    name: 'üìà Stats sau n√¢ng c·∫•p',
                    value: this.getUpgradePreview(itemInfo, targetLevel),
                    inline: false
                }
            )
            .setTimestamp();

        const actionRow = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId(`confirm_upgrade_${itemId}_${targetLevel}`)
                    .setLabel('‚¨ÜÔ∏è X√°c nh·∫≠n n√¢ng c·∫•p')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji('üî•'),
                new ButtonBuilder()
                    .setCustomId(`use_protection_scroll_${itemId}`)
                    .setLabel('üõ°Ô∏è D√πng Protection Scroll')
                    .setStyle(ButtonStyle.Success)
                    .setEmoji('üìú')
                    .setDisabled(!this.hasProtectionScroll(player)),
                new ButtonBuilder()
                    .setCustomId('cancel_upgrade')
                    .setLabel('‚ùå H·ªßy b·ªè')
                    .setStyle(ButtonStyle.Secondary)
                    .setEmoji('üö´')
            );

        message.reply({ embeds: [upgradeEmbed], components: [actionRow] });
    },

    // Helper methods
    getDetailedItemInfo(itemId) {
        // Extended item database with more detailed information
        const itemDatabase = {
            // Weapons
            'wooden_sword': {
                name: 'Wooden Sword', rarity: '‚ö™', category: 'weapons',
                attack: 20, crit: 2, price: 500, minLevel: 1, minRealm: 'Ph√†m Nh√¢n',
                weaponType: 'Sword', durability: 100, craftable: true, upgradable: true, maxUpgrade: 10,
                description: 'M·ªôt thanh ki·∫øm g·ªó ƒë∆°n gi·∫£n, ph√π h·ª£p cho ng∆∞·ªùi m·ªõi b·∫Øt ƒë·∫ßu.',
                specialEffects: ['Lightweight: +5% attack speed']
            },
            'iron_sword': {
                name: 'Iron Sword', rarity: 'üü¢', category: 'weapons',
                attack: 50, crit: 5, price: 2000, minLevel: 5, minRealm: 'Luy·ªán Th·ªÉ',
                weaponType: 'Sword', durability: 150, craftable: true, upgradable: true, maxUpgrade: 12,
                description: 'Thanh ki·∫øm s·∫Øt r√®n t·ª´ qu·∫∑ng s·∫Øt ch·∫•t l∆∞·ª£ng cao.',
                specialEffects: ['Sharp Edge: +10% crit damage', 'Durable: +50% durability']
            },
            'steel_blade': {
                name: 'Steel Blade', rarity: 'üîµ', category: 'weapons',
                attack: 120, crit: 8, price: 8000, minLevel: 15, minRealm: 'Luy·ªán Kh√≠',
                weaponType: 'Sword', durability: 200, craftable: true, upgradable: true, maxUpgrade: 15,
                description: 'L∆∞·ª°i ki·∫øm th√©p b√≥ng lo√°ng v·ªõi s·ª©c m·∫°nh c·∫Øt ph√° tuy·ªát v·ªùi.',
                specialEffects: ['Steel Edge: +15% crit damage', 'Balanced: +10% accuracy']
            },

            // Armor
            'cloth_robe': {
                name: 'Cloth Robe', rarity: '‚ö™', category: 'armor',
                defense: 15, hp: 20, price: 400, minLevel: 1, minRealm: 'Ph√†m Nh√¢n',
                armorType: 'Robe', weight: 'Light', craftable: true, upgradable: true, maxUpgrade: 8,
                description: '√Åo cho√†ng v·∫£i ƒë∆°n gi·∫£n cho nh·ªØng tu sƒ© m·ªõi v√†o ƒë·∫°o.',
                resistances: ['Wind: +5%']
            },
            'leather_armor': {
                name: 'Leather Armor', rarity: 'üü¢', category: 'armor',
                defense: 35, hp: 50, price: 1500, minLevel: 5, minRealm: 'Luy·ªán Th·ªÉ',
                armorType: 'Leather', weight: 'Medium', craftable: true, upgradable: true, maxUpgrade: 10,
                description: 'Gi√°p da b·ªÅn ch·∫Øc, cung c·∫•p s·ª± b·∫£o v·ªá t·ªët m√† v·∫´n linh ho·∫°t.',
                resistances: ['Physical: +10%', 'Pierce: +15%']
            },

            // Pills
            'health_pill': {
                name: 'Health Pill', rarity: '‚ö™', category: 'pills',
                effect: '+100 HP', duration: '1h', cooldown: '30m', price: 50,
                stackLimit: 10, craftable: true,
                description: 'Vi√™n thu·ªëc h·ªìi ph·ª•c sinh l·ª±c c∆° b·∫£n.',
                sideEffects: []
            },
            'exp_pill': {
                name: 'EXP Pill', rarity: 'üîµ', category: 'pills',
                effect: '+500 EXP', duration: 'Instant', cooldown: '1h', price: 1000,
                stackLimit: 5, craftable: true,
                description: 'Vi√™n thu·ªëc tƒÉng kinh nghi·ªám qu√Ω hi·∫øm.',
                sideEffects: ['Temporary fatigue: -10% stats for 30m']
            }
        };

        return itemDatabase[itemId] || null;
    },

    getRarityColor(rarity) {
        const colors = {
            '‚ö™': '#FFFFFF', // Common - White
            'üü¢': '#00FF00', // Uncommon - Green  
            'üîµ': '#0080FF', // Rare - Blue
            'üü£': '#8000FF', // Epic - Purple
            'üü†': '#FF8000', // Legendary - Orange
            'üü°': '#FFD700'  // Mythic - Gold
        };
        return colors[rarity] || '#FFFFFF';
    },

    getRarityName(rarity) {
        const names = {
            '‚ö™': 'Common',
            'üü¢': 'Uncommon', 
            'üîµ': 'Rare',
            'üü£': 'Epic',
            'üü†': 'Legendary',
            'üü°': 'Mythic'
        };
        return names[rarity] || 'Unknown';
    },

    getItemStatsText(itemInfo) {
        const stats = [];
        if (itemInfo.attack) stats.push(`Attack: ${itemInfo.attack}`);
        if (itemInfo.defense) stats.push(`Defense: ${itemInfo.defense}`);
        if (itemInfo.hp) stats.push(`HP: +${itemInfo.hp}`);
        if (itemInfo.crit) stats.push(`Crit: ${itemInfo.crit}%`);
        if (itemInfo.durability) stats.push(`Durability: ${itemInfo.durability}`);
        return stats.join('\n') || 'No combat stats';
    },

    getComparisonText(item) {
        const stats = [];
        if (item.attack) stats.push(`Attack: ${item.attack}`);
        if (item.defense) stats.push(`Defense: ${item.defense}`);
        if (item.hp) stats.push(`HP: +${item.hp}`);
        if (item.crit) stats.push(`Crit: ${item.crit}%`);
        stats.push(`Price: ${item.price?.toLocaleString() || 'N/A'}`);
        return stats.join('\n');
    },

    getComparisonDifference(item1, item2) {
        const diffs = [];
        
        if (item1.attack && item2.attack) {
            const diff = item2.attack - item1.attack;
            const color = diff > 0 ? 'üü¢' : diff < 0 ? 'üî¥' : '‚ö™';
            diffs.push(`${color} Attack: ${diff > 0 ? '+' : ''}${diff}`);
        }
        
        if (item1.defense && item2.defense) {
            const diff = item2.defense - item1.defense;
            const color = diff > 0 ? 'üü¢' : diff < 0 ? 'üî¥' : '‚ö™';
            diffs.push(`${color} Defense: ${diff > 0 ? '+' : ''}${diff}`);
        }
        
        if (item1.hp && item2.hp) {
            const diff = item2.hp - item1.hp;
            const color = diff > 0 ? 'üü¢' : diff < 0 ? 'üî¥' : '‚ö™';
            diffs.push(`${color} HP: ${diff > 0 ? '+' : ''}${diff}`);
        }
        
        return diffs.join('\n') || 'No differences';
    },

    getRecommendation(item1, item2) {
        let score1 = 0;
        let score2 = 0;
        
        // Simple scoring system
        score1 += (item1.attack || 0) + (item1.defense || 0) + (item1.hp || 0) + (item1.crit || 0);
        score2 += (item2.attack || 0) + (item2.defense || 0) + (item2.hp || 0) + (item2.crit || 0);
        
        if (score1 > score2) {
            return `üí° **${item1.name}** c√≥ stats t·ªïng th·ªÉ t·ªët h∆°n (${score1} vs ${score2})`;
        } else if (score2 > score1) {
            return `üí° **${item2.name}** c√≥ stats t·ªïng th·ªÉ t·ªët h∆°n (${score2} vs ${score1})`;
        } else {
            return 'üí° C·∫£ hai items c√≥ stats t∆∞∆°ng ƒë∆∞∆°ng, h√£y ch·ªçn theo s·ªü th√≠ch c√° nh√¢n.';
        }
    },

    getCraftableItemsCount(player) {
        // This would check against available recipes and materials
        return Math.floor(Object.keys(player.inventory.materials || {}).length / 2);
    },

    getUpgradableItemsCount(player) {
        // Count items that can be upgraded
        let count = 0;
        for (const category of ['weapons', 'armor']) {
            for (const itemId in player.inventory[category] || {}) {
                if (player.inventory[category][itemId] > 0) {
                    const itemInfo = this.getDetailedItemInfo(itemId);
                    if (itemInfo?.upgradable) count++;
                }
            }
        }
        return count;
    },

    getEnchantableItemsCount(player) {
        // Similar to upgradable but for enchantments
        return this.getUpgradableItemsCount(player);
    },

    getUnlockedRecipes(player) {
        // This would check player's crafting progress
        return Math.min(player.level, 20);
    },

    getAvailableEnchants(player) {
        return Math.floor(player.level / 5);
    },

    getCategoryEmoji(category) {
        const emojis = {
            weapons: '‚öîÔ∏è',
            armor: 'üõ°Ô∏è',
            pills: 'üíä',
            accessories: 'üíç',
            materials: 'üîÆ'
        };
        return emojis[category] || 'üì¶';
    },

    getCraftingLevel(player) {
        // Based on items crafted or player level
        return Math.floor(player.level / 3) + 1;
    },

    getAvailableRecipes(player) {
        // Mock recipes - in real implementation this would be more complex
        return [
            {
                id: 'iron_sword_recipe',
                category: 'weapons',
                result: { name: 'Iron Sword', rarity: 'üü¢' },
                materials: [
                    { name: 'Iron Ore', quantity: 5 },
                    { name: 'Wood', quantity: 2 }
                ],
                cost: 500
            }
        ];
    },

    getLockedRecipes(player) {
        // Mock locked recipes
        return [
            {
                id: 'legendary_sword_recipe',
                category: 'weapons',
                result: { name: 'Legendary Sword', rarity: 'üü†' },
                requirements: 'Reach level 50'
            }
        ];
    },

    getCraftingRecipe(recipeId) {
        // Get specific recipe by ID
        const recipes = this.getAvailableRecipes({ level: 100 }); // Mock high level player
        return recipes.find(r => r.id === recipeId);
    },

    canCraftItem(player, recipe, quantity = 1) {
        // Check if player has enough materials and coins
        for (const material of recipe.materials) {
            const needed = material.quantity * quantity;
            const has = player.inventory.materials?.[material.name.toLowerCase().replace(' ', '_')] || 0;
            
            if (has < needed) {
                return {
                    success: false,
                    message: `Kh√¥ng ƒë·ªß ${material.name}! C·∫ßn: ${needed}, c√≥: ${has}`
                };
            }
        }
        
        const totalCost = recipe.cost * quantity;
        if (player.coins < totalCost) {
            return {
                success: false,
                message: `Kh√¥ng ƒë·ªß coins! C·∫ßn: ${totalCost.toLocaleString()}, c√≥: ${player.coins.toLocaleString()}`
            };
        }
        
        return { success: true };
    },

    calculateCraftingSuccess(player, recipe) {
        // Base success rate with modifiers
        let baseRate = 90;
        const craftingLevel = this.getCraftingLevel(player);
        
        // Higher level = higher success rate
        baseRate += Math.min(craftingLevel * 2, 10);
        
        return Math.min(baseRate, 99);
    },

    hasRecipeUnlocked(player, recipeId) {
        // Check if player has unlocked this recipe
        // For now, assume all basic recipes are unlocked
        return player.level >= 1;
    },

    playerHasUpgradableItem(player, itemId) {
        const categories = ['weapons', 'armor'];
        
        for (const category of categories) {
            if (player.inventory[category]?.[itemId] > 0) {
                const itemInfo = this.getDetailedItemInfo(itemId);
                if (itemInfo?.upgradable) {
                    return { success: true };
                }
            }
        }
        
        return {
            success: false,
            message: 'B·∫°n kh√¥ng c√≥ item n√†y ho·∫∑c item kh√¥ng th·ªÉ n√¢ng c·∫•p!'
        };
    },

    getItemUpgradeLevel(player, itemId) {
        // Get current upgrade level of item (stored in player data)
        return player.itemUpgrades?.[itemId] || 0;
    },

    getUpgradeCost(itemInfo, levels) {
        // Calculate cost for upgrading X levels
        const baseCost = itemInfo.price || 1000;
        let totalCost = 0;
        
        for (let i = 1; i <= levels; i++) {
            totalCost += Math.floor(baseCost * 0.5 * Math.pow(1.5, i));
        }
        
        return totalCost;
    },

    calculateUpgradeSuccess(currentLevel, targetLevel) {
        // Success rate decreases with higher levels
        const baseRate = 90;
        const levelPenalty = (currentLevel + targetLevel) * 2;
        
        return Math.max(baseRate - levelPenalty, 10);
    },

    getUpgradePreview(itemInfo, targetLevel) {
        const multiplier = 1 + (targetLevel * 0.1); // 10% per level
        const stats = [];
        
        if (itemInfo.attack) {
            stats.push(`Attack: ${Math.floor(itemInfo.attack * multiplier)}`);
        }
        if (itemInfo.defense) {
            stats.push(`Defense: ${Math.floor(itemInfo.defense * multiplier)}`);
        }
        if (itemInfo.hp) {
            stats.push(`HP: +${Math.floor(itemInfo.hp * multiplier)}`);
        }
        
        return stats.join('\n');
    },

    hasProtectionScroll(player) {
        return player.inventory.special?.['protection_scroll'] > 0;
    }
};
